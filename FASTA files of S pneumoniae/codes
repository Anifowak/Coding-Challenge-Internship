# Load required libraries
if (!requireNamespace("BiocManager", quietly = TRUE))
   install.packages("BiocManager")
BiocManager::install("Biostrings")
install.packages("stringr") 

# Load libraries
library(Biostrings)
library(stringr)

# Function to read DNA sequence from a FASTA file and count 14-mers
count_14mers <- function(file_path) {
   # Step 1: Read DNA sequence from FASTA file
   dna_sequences <- readDNAStringSet(file_path)
   
   # Step 2: Concatenate all sequences into one long string (if multiple sequences)
   dna_string <- paste(as.character(dna_sequences), collapse = "")
   
   # Step 3: Extract 14-mers from the sequence
   generate_kmers <- function(dna_sequence, k) {
      seq_length <- nchar(dna_sequence)  # Get the length of the sequence
      kmers <- vector("character", seq_length - k + 1)  # Pre-allocate a vector for k-mers
      for (i in 1:(seq_length - k + 1)) {
         kmers[i] <- substr(dna_sequence, i, i + k - 1)  # Extract the k-mer
      }
      return(kmers) 
   }
   
   kmers <- generate_kmers(dna_string, 14)
   
   # Step 4: Count occurrences of each 14-mer
   kmer_counts <- table(kmers) # Create a frequency table
   
   # Return the 14-mer counts as a named vector
   return(kmer_counts)
}

# Function to count 14-mers from multiple FASTA files
count_14mers_from_files <- function(file_paths) {
   # Initialize an empty list to store the 14-mer counts for each file
   all_kmer_counts <- list()
   
   # Loop through each file and count 14-mers
   for (file_path in file_paths) {
      message("Processing file: ", file_path)
      kmer_counts <- count_14mers(file_path)
      all_kmer_counts[[file_path]] <- kmer_counts
   }
   
   return(all_kmer_counts)
}


# List of FASTA files to process
fasta_files <- c("C:/Users/anifo/OneDrive/Desktop/EMBL-EBI Internship/R6.fa", "C:/Users/anifo/OneDrive/Desktop/EMBL-EBI Internship/TIGR4.fa", "C:/Users/anifo/OneDrive/Desktop/EMBL-EBI Internship/14412_3#82.contigs_velvet.fa", "C:/Users/anifo/OneDrive/Desktop/EMBL-EBI Internship/14412_3#84.contigs_velvet.fa")

# Count 14-mers in each file and store the results in a list
all_kmer_counts <- count_14mers_from_files(fasta_files)

# View the 14-mer counts for one file (e.g., first file)
print(all_kmer_counts[[1]])
print(all_kmer_counts[[2]])
print(all_kmer_counts[[3]])
print(all_kmer_counts[[4]])


#STAGE 2
# Function to calculate Jaccard distance between two 14-mer dictionaries
calculate_jaccard_distance <- function(all_kmer_counts1, all_kmer_counts2) {
   
   # Step 1: Extract unique 14-mers (ignoring counts) from the two dictionaries
   kmers1 <- names(all_kmer_counts[[1]])  # Get names of 14-mers present in sample 1
   kmers2 <- names(all_kmer_counts[[2]])  # Get names of 14-mers present in sample 2
   
   # Step 2: Calculate the intersection and union of the two sets
   intersection <- length(intersect(kmers1, kmers2)) # Number of shared 14-mers
   union <- length(union(kmers1, kmers2))            # Total number of unique 14-mers
   
   # Step 3: Calculate Jaccard distance
   jaccard_distance <- 1 - (intersection / union)
   
   return(jaccard_distance)
}


# Calculate the Jaccard distance between the two samples
jaccard_distance <- calculate_jaccard_distance(kmers1, kmers2)
print(paste("Jaccard distance between the two samples is:", round(jaccard_distance, 4)))

# Function to calculate Jaccard distance between two 14-mer dictionaries
calculate_jaccard_distance <- function(all_kmer_counts3, all_kmer_counts4) {
   
   # Step 1: Extract unique 14-mers (ignoring counts) from the two dictionaries
   kmers3 <- names(all_kmer_counts[[3]])  # Get names of 14-mers present in sample 1
   kmers4 <- names(all_kmer_counts[[4]])  # Get names of 14-mers present in sample 2
   
   # Step 2: Calculate the intersection and union of the two sets
   intersection <- length(intersect(kmers3, kmers4)) # Number of shared 14-mers
   union <- length(union(kmers3, kmers4))            # Total number of unique 14-mers
   
   # Step 3: Calculate Jaccard distance
   jaccard_distance <- 1 - (intersection / union)
   
   return(jaccard_distance)
}


# Calculate the Jaccard distance between the two samples
jaccard_distance <- calculate_jaccard_distance(kmers3, kmers4)
print(paste("Jaccard distance between the two samples is:", round(jaccard_distance, 4)))


#STAGE 3

# Function to read the DNA sequence from a file
read_sequence_from_file <- function(file_path) {
   # Read the sequence from the FASTA file using Biostrings
   dna_sequence <- readDNAStringSet(file_path)
   
   # Convert the DNA sequence to a character string
   sequence <- as.character(dna_sequence[[1]])
   
   return(sequence)
}

# Function to generate k-mers from a sequence
generate_kmers <- function(sequence, k) {
   seq_length <- nchar(sequence)  # Get the length of the sequence
   kmers <- vector("character", seq_length - k + 1)  # Pre-allocate a vector for k-mers
   for (i in 1:(seq_length - k + 1)) {
      kmers[i] <- substr(sequence, i, i + k - 1)  # Extract the k-mer
   }
   return(kmers)
}

# Example file path (change this to the actual file path)
file_path <- c("C:/Users/anifo/OneDrive/Desktop/EMBL-EBI Internship/TIGR4.fa")

# Read sequence from the file
sequence <- read_sequence_from_file(file_path)

# Set the k-mer length
k <- 14

# Generate k-mers from the sequence
kmers <- generate_kmers(sequence, k)

# Print the k-mers
print(kmers)

library(digest)

# generate reverse complement of DNA sequence
get_reverse_complement <- function(dna_sequence) {
   # Define the complement pairs
   complements <- c(A = "T", T = "A", C = "G", G = "C")
   
   # Split the sequence into individual characters
   dna_chars <- unlist(strsplit(dna_sequence, split = ""))
   
   # Get the complement for each character
   complement_chars <- complements[dna_chars]
   
   # Reverse the complemented sequence and paste it back together
   reverse_complement <- paste(rev(complement_chars), collapse = "")
   
   return(reverse_complement)
}

# some 14-mers for this example
kmers <- c("CCTCACCCACTCCC", 
           "CTCACCCACTCCCA", 
           "TCACCCACTCCCAA",
           "CACCCACTCCCAAG", 
           "ACCCACTCCCAAGT", 
           "CCCACTCCCAAGTA",
           "CCACTCCCAAGTAT", 
           "CACTCCCAAGTATC", 
           "ACTCCCAAGTATCA",
           "CTCCCAAGTATCAG")

# get reverse complements
kmers_rev_comp <- sapply(kmers, get_reverse_complement)

# calculate a hash of the first k-mer, this comes back as a hex string. You could convert this to an integer (be aware this may be difficult in R as integers are 32-bits), but just using these hex strings directly for the steps below will work just as well
hash1 <- digest(kmers[1], algo = "murmur32", serialize = F, seed = 0)
hash1

# Run on all the k-mers in forward and reverse direction
hash_run1_forward <- unlist(lapply(kmers, digest, algo = "murmur32", serialize = F, seed = 0))
hash_run1_reverse <- unlist(lapply(kmers_rev_comp, digest, algo = "murmur32", serialize = F, seed = 0))

# use pmin to get the lowest hash for each pair of k-mers
hash_run1 <- pmin(hash_run1_forward, hash_run1_reverse)
hash_run1

# Confirm the same hashes are generated on repeated runs (so they are comparable between samples)
hash_run2_forward <- unlist(lapply(kmers, digest, algo = "murmur32", serialize = F, seed = 0))
hash_run2_reverse <- unlist(lapply(kmers_rev_comp, digest, algo = "murmur32", serialize = F, seed = 0))
hash_run2 <- pmin(hash_run2_forward, hash_run2_reverse)

all(hash_run1 == hash_run2)
